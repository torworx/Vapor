package evymind.vapor.deploy.test;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Properties;
import org.junit.Assert;

import com.google.common.collect.Lists;

import evyframework.common.io.FileSystemResource;
import evyframework.common.io.Resource;
import evyframework.common.io.UrlResource;
import evyframework.common.io.support.ResourcePatternResolver;
import evyframework.common.io.support.ResourcePatternUtils;
import evyframework.common.io.utils.FileUtils;
import evymind.vapor.app.AppContext;
import evymind.vapor.client.DefaultServiceProxyInvoker;
import evymind.vapor.client.ServiceProxyInvoker;
import evymind.vapor.client.supertcp.SuperTCPChannel;
import evymind.vapor.config.Configuration;
import evymind.vapor.config.DefaultConfiguration;
import evymind.vapor.core.message.bin.BinMessageFactory;
import evymind.vapor.deploy.DeploymentManager;
import evymind.vapor.server.Connector;
import evymind.vapor.server.Handler;
import evymind.vapor.server.Server;
import evymind.vapor.server.handler.HandlerCollection;
import evymind.vapor.toolchain.test.PathAssert;
import evymind.vapor.toolchain.test.TestingDir;
import evymind.vapor.toolchain.test.TestingUtils;

public class ConfiguredVapor {

	private ResourcePatternResolver resolver = ResourcePatternUtils.getDefaultResourcePatternResolver();

	private List<Resource> configurationResources = Lists.newArrayList();
	private Properties properties = new Properties();
	private Server server;
	private int serverPort;
	private File vaporHome;

	public ConfiguredVapor(TestingDir testdir) throws IOException {
		Properties properties = new Properties();

		String vaporHomeBase = testdir.getDir().getAbsolutePath();
		// Ensure we have a new (pristene) directory to work with.
		int idx = 0;
		vaporHome = new File(vaporHomeBase + "#" + idx);
		while (vaporHome.exists()) {
			idx++;
			vaporHome = new File(vaporHomeBase + "#" + idx);
		}
		deleteContents(vaporHome);
		// Prepare Jetty.Home (Test) dir
		vaporHome.mkdirs();

		File logsDir = new File(vaporHome, "logs");
		logsDir.mkdirs();

		File etcDir = new File(vaporHome, "etc");
		etcDir.mkdirs();
		// IO.copyFile(TestingUtils.getTestResourceFile("etc/realm.properties"),new File(etcDir,"realm.properties"));
		// IO.copyFile(TestingUtils.getTestResourceFile("etc/webdefault.xml"),new File(etcDir,"webdefault.xml"));

		File contextsDir = new File(vaporHome, "contexts");
		if (contextsDir.exists()) {
			deleteContents(contextsDir);
		}
		contextsDir.mkdirs();

		File appsDir = new File(vaporHome, "apps");
		if (appsDir.exists()) {
			deleteContents(appsDir);
		}
		appsDir.mkdirs();

		File tmpDir = new File(vaporHome, "tmp");
		if (tmpDir.exists()) {
			deleteContents(tmpDir);
		}
		tmpDir.mkdirs();

		File workishDir = new File(vaporHome, "workish");
		if (workishDir.exists()) {
			deleteContents(workishDir);
		}
		workishDir.mkdirs();

		// Setup properties
		System.setProperty("java.io.tmpdir", tmpDir.getAbsolutePath());
		properties.setProperty("vapor.home", vaporHome.getAbsolutePath());
		System.setProperty("vapor.home", vaporHome.getAbsolutePath());
		properties.setProperty("test.basedir", TestingUtils.getBasedir().getAbsolutePath());
		properties.setProperty("test.resourcesdir", TestingUtils.getTestResourcesDir().getAbsolutePath());
		properties.setProperty("test.apps", appsDir.getAbsolutePath());
		properties.setProperty("test.targetdir", TestingUtils.getTargetDir().getAbsolutePath());
		properties.setProperty("test.workdir", workishDir.getAbsolutePath());

		// Write out configuration for use by ConfigurationManager.
		File testConfig = new File(vaporHome, "xml-configured-vapor.properties");
		FileOutputStream out = new FileOutputStream(testConfig);
		properties.store(out, "Generated by " + getClass().getName());
		this.properties.putAll(properties);
//		for (Object key : properties.keySet()) {
//			this.properties.put(String.valueOf(key), String.valueOf(properties.get(key)));
//		}
	}

	public void addConfiguration(Resource... resources) {
		for (Resource resource : resources) {
			this.configurationResources.add(resource);
		}
	}

	public void addConfiguration(String configFile) {
		addConfiguration(resolver.getResource(configFile));
	}

	public void addConfiguration(File configFile) {
		addConfiguration(new FileSystemResource(configFile));
	}

	public void addConfiguration(URL configFile) {
		addConfiguration(new UrlResource(configFile));
	}

	private void deleteContents(File dir) {
		System.out.printf("Delete  (dir) %s/%n", dir);
		if (!dir.exists()) {
			return;
		}

		for (File file : dir.listFiles()) {
			// Safety measure. only recursively delete within target directory.
			if (file.isDirectory() && file.getAbsolutePath().contains("target" + File.separator)) {
				deleteContents(file);
				Assert.assertTrue("Delete failed: " + file.getAbsolutePath(), file.delete());
			} else {
				System.out.printf("Delete (file) %s%n", file);
				Assert.assertTrue("Delete failed: " + file.getAbsolutePath(), file.delete());
			}
		}
	}

	public ServiceProxyInvoker getServiceProxyInvoker() {
		SuperTCPChannel channel = new SuperTCPChannel();
		channel.connect("localhost");
		return new DefaultServiceProxyInvoker(new BinMessageFactory().createMessage(), channel);
	}
	
	public void assertNoAppContexts() {
		List<AppContext> contexts = getAppContexts();
		if (contexts.size() > 0) {
			for (AppContext context : contexts) {
				System.out.println("AppContext should not exist:\n" + context);
			}
			Assert.assertEquals("Contexts.size", 0, contexts.size());
		}
	}

	public void assertResponseContains(Invoker invoker, String needle) throws IOException {
		System.out.println("Issuing request to " + invoker);
		String content = (String) invoker.invoke();
		Assert.assertTrue("Content should contain <" + needle + ">, instead got <" + content + ">",
				content.contains(needle));
	}

	public void assertAppContextsExists(String... expectedContextPaths) {
		List<AppContext> contexts = getAppContexts();
		if (expectedContextPaths.length != contexts.size()) {
			System.out.println("## Expected Contexts");
			for (String expected : expectedContextPaths) {
				System.out.println(expected);
			}
			System.out.println("## Actual Contexts");
			for (AppContext context : contexts) {
				System.out.printf("%s ## %s%n", context.getContextPath(), context);
			}
			Assert.assertEquals("Contexts.size", expectedContextPaths.length, contexts.size());
		}

		for (String expectedPath : expectedContextPaths) {
			boolean found = false;
			for (AppContext context : contexts) {
				if (context.getContextPath().equals(expectedPath)) {
					found = true;
					break;
				}
			}
			Assert.assertTrue("Did not find Expected Context Path " + expectedPath, found);
		}
	}

	public void copyContext(String srcName, String destName) throws IOException {
		System.out.printf("Copying Context: %s -> %s%n", srcName, destName);
		File srcDir = TestingUtils.getTestResourceDir("contexts");
		File destDir = new File(this.vaporHome, "contexts");

		File srcFile = new File(srcDir, srcName);
		File destFile = new File(destDir, destName);

		copyFile("Context", srcFile, destFile);
	}

	private void copyFile(String type, File srcFile, File destFile) throws IOException {
		PathAssert.assertFileExists(type + " File", srcFile);
		FileUtils.copy(srcFile, destFile);
		PathAssert.assertFileExists(type + " File", destFile);
		System.out.printf("Copy %s: %s%n  To %s: %s%n", type, srcFile, type, destFile);
		System.out.printf("Destination Exists: %s - %s%n", destFile.exists(), destFile);
	}

	public void copyApp(String srcName, String destName) throws IOException {
		System.out.printf("Copying App: %s -> %s%n", srcName, destName);
		File srcDir = TestingUtils.getTestResourceDir("apps");
		File destDir = new File(this.vaporHome, "apps");

		File srcFile = new File(srcDir, srcName);
		File destFile = new File(destDir, destName);

		copyFile("App", srcFile, destFile);
	}

	public DeploymentManager getActiveDeploymentManager() {
		return server.getBean(DeploymentManager.class);
	}

	public File getVaporDir(String name) {
		return new File(this.vaporHome, name);
	}

	public File getVaporHome() {
		return this.vaporHome;
	}

	public Server getServer() {
		return server;
	}

	public int getServerPort() {
		return serverPort;
	}

//	public URI getServerURI() throws UnknownHostException {
//		StringBuffer uri = new StringBuffer();
//		uri.append(this._scheme).append("://");
//		uri.append(InetAddress.getLocalHost().getHostAddress());
//		uri.append(":").append(this.serverPort);
//		return URI.create(uri.toString());
//	}

	public List<AppContext> getAppContexts() {
		List<AppContext> contexts = new ArrayList<AppContext>();
		HandlerCollection handlers = (HandlerCollection) server.getHandler();
		System.out.println(server.dump());
		Handler children[] = handlers.getChildHandlers();

		for (Handler handler : children) {
			if (handler instanceof AppContext) {
				AppContext context = (AppContext) handler;
				contexts.add(context);
			}
		}

		return contexts;
	}

	public void load() throws Exception {
//		Configuration last = null;
//		Object[] obj = new Object[this.configurations.size()];
//
//		// Configure everything
//		for (int i = 0; i < this.configurations.size(); i++) {
//			URL configURL = this.configurations.get(i);
//			XmlConfiguration configuration = new XmlConfiguration(configURL);
//			if (last != null) {
//				configuration.getIdMap().putAll(last.getIdMap());
//			}
//			configuration.getProperties().putAll(this.properties);
//			obj[i] = configuration.configure();
//			last = configuration;
//		}
//
//		// Test for Server Instance.
//		Server foundServer = null;
//		int serverCount = 0;
//		for (int i = 0; i < this.configurations.size(); i++) {
//			if (obj[i] instanceof Server) {
//				if (obj[i].equals(foundServer)) {
//					// Identical server instance found
//					break;
//				}
//				foundServer = (Server) obj[i];
//				serverCount++;
//			}
//		}
		Configuration configuration = new DefaultConfiguration();
//		SpringConfiguration configuration = new SpringConfiguration(configurationResources.toArray(new URL[configurationResources.size()]));
		configuration.setProperties(this.properties);
		configuration.load(configurationResources.toArray(new Resource[configurationResources.size()]));
		Collection<Server> servers = configuration.getInstancesOfType(Server.class).values();

		if (servers == null || servers.isEmpty()) {
			throw new Exception("Load failed to configure a " + Server.class.getName());
		}

		Assert.assertEquals("Server load count", 1, servers.size());

		this.server = servers.iterator().next();
		this.server.setGracefulShutdown(10);

	}

	public void removeContext(String name) {
		File destDir = new File(this.vaporHome, "contexts");
		File contextFile = new File(destDir, name);
		if (contextFile.exists()) {
			Assert.assertTrue("Delete of Context file: " + contextFile.getAbsolutePath(), contextFile.delete());
		}
	}

	public void setProperty(String key, String value) {
		this.properties.put(key, value);
	}

	public void start() throws Exception {
		Assert.assertNotNull("Server should not be null (failed load?)", server);

		server.start();

		// Find the active server port.
		this.serverPort = (-1);
		Connector connectors[] = server.getConnectors();
		for (int i = 0; i < connectors.length; i++) {
			Connector connector = connectors[i];
			if (connector.getPort() > 0) {
				this.serverPort = connector.getPort();
				break;
			}
		}

		Assert.assertTrue("Server Port is between 1 and 65535. Actually <" + serverPort + ">", (1 <= this.serverPort)
				&& (this.serverPort <= 65535));

		// Uncomment to have server start and continue to run (without exiting)
		// System.out.printf("Listening to port %d%n",this.serverPort);
		// server.join();
	}

	public void stop() throws Exception {
		if (server != null) {
			server.stop();
		}
	}

}
